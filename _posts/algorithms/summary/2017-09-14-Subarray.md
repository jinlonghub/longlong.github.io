---
layout: post
title: "Subarray"
date: 2017-09-14 23:00:00 +0800 
categories: Algorithms
tag: Array_Subarray
---
* content
{:toc}

---

<!-- more -->

## Subarray专题

- Subarray解题思路：遇到Subarray相关的问题，一定要想到`prefix sum`（前缀和数组）。    
- 什么是`prefix sum`：   
  - 一维数组`prefix sum`：`prefix_sum[i] = sigma{nums[0 ~ i]}` （`sigma`是数学中的求和符号）    
                           可以在O(1)时间内，求出`sum[i ~j] = sum[j] - sum[i - 1]`。        
  ![liner_prefix_sum]({{ '/styles/images/algorithms/2017-09-14-Subarray/liner_prefix_sum.png' | prepend: site.baseurl }})    
  - 二维数组`prefix sum`：`prefix_sum[x - i][y - j] = sum[x][y] - sum[x][j - 1] - sum[i - 1][y] + sum[i][j]`      
  ![two-dimensional_prefix_sum]({{ '/styles/images/algorithms/2017-09-14-Subarray/two-dimensional_prefix_sum.png' | prepend: site.baseurl }})     
  - 有了`prefix sum`可以在O(1)时间，求出任意一段的sum。但前提是需要用O(n)的预处理时间来构建`prefix sum`。这个O(n)的时间开销很有价值，因为如果没有这个预处理时间，每求一次sum都需要有O(n)的时间。（对应n*n的二维矩阵就是O(n^2)时间复杂度）






---


## Description:    
Write a program to find the n-th ugly number.     
**Ugly numbers** are positive numbers whose prime factors only include 2, 3, 5. 
For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers..    
Note that **1** is typically treated as an ugly number, and n does not exceed 1690. 

 ### Follow up:    
Could you do both operations in O(nlog n) or O(n) time. time complexity?    

 ### Example:     
If n=9, return 10.

---
    
<!-- TOC -->

## Solution:    
- 丑数(Ugly Number)：从1开始，以2,3,5为因数的正数。    
- 丑数的生成：`{1}`是定义的丑数；用`{1}`分别`*`2/ 3/ 5 可得`{2，3，5}`放回原集合；从`{2，3，5}`中取最小数，再分别`*`2/ 3/ 5 可得`{4，6，10}` 以此循环。       
  即，从生成的集合中依次取最小值分别`*`2/ 3/ 5，然后再把结果放回原集合。
- 根据分析，我们需要一个集合，它能很快的插入数据，和求最小值。
- 提到求最小值，就想到**MinHeap**即**priority_queue**
- 因为考虑到`2 * 5` 和 `5 * 2`重复，为了去重，再搭配一个Hash_set 来判断当前的数据是否已经放到了集合中。 

---  

<!-- TOC -->   
       
## C++ Code:     

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        if (n == 1) return 1;
        priority_queue<long long, vector<long long>, greater<long long> > q;
        set<long long> q_set;
        long long num[3] = {2, 3, 5}; 
        long long res = 1;
        for (int i = 0; i < 3; i++) {
            q.push(num[i]);
            q_set.insert(num[i]);
        }
        for (int i = 1; i < n; i++) {
            res = q.top();
            q.pop();
            for (int j = 0; j < 3; j++) {
                if (q_set.find(res * num[j]) == q_set.end()) {
                    q.push(res * num[j]);
                    q_set.insert(res * num[j]);
                }
            }
        }
        return res;
    }
};

```

<!-- TOC -->

## Java Code:  

```java
//O(nlogn) HashMap + Heap
class Solution {
    /**
     * @param n an integer
     * @return the nth prime number as description.
     */
    public int nthUglyNumber(int n) {
        // Write your code here
        Queue<Long> Q = new PriorityQueue<Long>();
        HashSet<Long> inQ = new HashSet<Long>();
        Long[] primes = new Long[3];
        primes[0] = Long.valueOf(2);
        primes[1] = Long.valueOf(3);
        primes[2] = Long.valueOf(5);
        for (int i = 0; i < 3; i++) {
            Q.add(primes[i]);
            inQ.add(primes[i]);
        }
        Long number = Long.valueOf(1);
        for (int i = 1; i < n; i++) {
            number = Q.poll();
            for (int j = 0; j < 3; j++) {
                if (!inQ.contains(primes[j] * number)) {
                    Q.add(number * primes[j]);
                    inQ.add(number * primes[j]);
                }
            }
        }
        return number.intValue();
    }
};

```

---

<!-- TOC -->

## 总结：   
1. int、long、long long 的取值范围：     
>unsigned int   0～4294967295      
>         int   -2147483648～2147483647   
>
>unsigned long  0～4294967295   
>         long  -2147483648～2147483647 
>
>long long的最大值：9223372036854775807        
>long long的最小值：-9223372036854775808    
>unsigned long long的最大值：1844674407370955161    
> `(long long 是**64bit存储**, int和long都是**32bit存储**)`
>
>__int64的最大值：9223372036854775807   
>__int64的最小值：-9223372036854775808   
>unsigned __int64的最大值：18446744073709551615     

2. `Heap`
  +  `Heap` 是Tree结构，是“从上到下，从左到右” 尽量填充满的`二叉树`，分为：     
     `Max heap` ：root为最大值，左右节点的值，均小于父节点，左右节点的大小无法确定。     
     `Min heap` ：root为最小值，左右节点的值，均大于父节点，左右节点的大小无法确定。

3. 二叉树，二叉查找树，平衡二叉查找树的区别     
  + `Binary Tree` ：           每个节点都**最多**有两个叉的树    
  + BST `Binary Search Tree` ：左节点<中间节点<右节点 的二叉树    
  + B-BST `Balance-BST` ：     任意节点的左右子树深度差值<=1 的BST    

    | `Binary Tree` | BST`Binary Search Tree` | B-BST`Balance-BST` |
    | ------------- | ----------------------- | ------------------ |
    | 每个节点都**最多**有两个叉的树 | 左节点<中间节点<右节点 的二叉树| 任意节点的左右子树深度差值<=1 的BST |


4. `priority_queue`专题     
  + `priority_queue` 本质上就是 `Heap`
  + 但是`priority_queue`实例化时，需要写成`queue`的形式，可以理解为`priority_queue`是`queue`的一种，因为`priority_queue`和`queue`有着相同的接口，    
     都支持q.push(); q.size();等…… 
     + **注意：**`q.top()` 是`priority_queue`独有的，`queue`没有；      
                     `q.front() 和 q.back()`是`queue`独有的，`priority_queue`没有。      
  + `C++ STL`中的`priority_queue`    
    + `priority_queue`在`C++`中的形式：`priority_queue<Type, Container, Compare>`     
       `Container`：保存数据的容器，且必须是数组实现的容器，STL默认为vector；    
       `Compare`：元素的比较方式，STL默认用`operator < `，即STL默认`priority_queue`为`MaxHeap` **堆顶是最大值**。
    + 如果使用STL默认的PQ形式(即`MaxHeap`形式)，则可以直接写成：`priority_queue<int> q;`
    + 如果想使用`MinHeap`的`priority_queue` 需要重载 `<`:
      + 对于 _基本数据类型_ ： 可用 _仿函数_ `greater<>`来完成重载：`priority_queue<int, vector<int>, greater<int> >`    
      + 对于 _自定义类型_ ：需要建立一个`struct` 去重载 `运算符<` :

      ```cpp
      struct cmp {
        bool operator () (int &a, int &b) {
            return a > b;
        }
      };

      class Solution {
      public: 
        priority_queue<int, vector<int>, cmp> q;
        ……
        ……
      };
      
      ```

---

`2017.09.13`       
