---
layout: post
title: "Subarray专题"
date: 2017-09-14 23:00:00 +0800 
categories: Algorithms
tag: Array_Subarray
---
* content
{:toc}

---

<!-- more -->

## Subarray专题

---

## Subarray相关问提解题思路          
  - Subarray解题思路：遇到Subarray相关的问题，一定要想到`prefix sum`（前缀和数组）。    
  - 什么是`prefix sum`：   
    - 一维数组`prefix sum`：`prefix_sum[i] = sigma{nums[0 ~ i]}` （`sigma`是数学中的求和符号）    
                           可以在O(1)时间内，求出`sum[i ~j] = sum[j] - sum[i - 1]`。        
    ![liner_prefix_sum]({{ '/styles/images/algorithms/2017-09-14-Subarray/liner_prefix_sum.png' | prepend: site.baseurl }})    
    - 二维数组`prefix sum`：`prefix_sum[x - i][y - j] = sum[x][y] - sum[x][j - 1] - sum[i - 1][y] + sum[i][j]`      
    ![two-dimensional_prefix_sum]({{ '/styles/images/algorithms/2017-09-14-Subarray/two-dimensional_prefix_sum.png' | prepend: site.baseurl }})     
    - 有了`prefix sum`可以在O(1)时间，求出任意一段的sum。但前提是需要用O(n)的预处理时间来构建`prefix sum`。这个O(n)的时间开销很有价值，因为如果没有这个预处理时间，每求一次sum都需要有O(n)的时间。（对应n*n的二维矩阵就是O(n^2)时间复杂度）。      

---  

---

## Subarray相关题目      

1. [Leetcode Link：Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/)      

  + **Description**          
    Given an array of integers, find a contiguous subarray which has the largest sum.         
    The subarray should contain at least one number.     

  + **Example**           
    Given the array `[−2,2,−3,4,−1,2,1,−5,3]`, the contiguous subarray `[4,−1,2,1]` has the largest `sum = 6`.    

  + **Solution**      
    - 求最大子序列，可以for一遍整体数组，把每个点的前缀和求出来；       
    - 用minSum记录之前最小的前缀和，用当前的前缀和sum `-` 之前最小前缀和，得到的就是maxSum的备选结果，在备选结果里找出最大即可。      
    - 注意minSum，在所有元素都是正数时，minSum是0；只有在有负数出现时，minSum才会取最小的元素值。##也就是说minSum的初始值为0##。     

  + **C++** **Code**              

```cpp  

class Solution {
public:
    /*
     * @param nums: A list of integers
     * @return: A integer indicate the sum of max subarray
     */
    int maxSubArray(vector<int> nums) {
        // write your code here
        if (nums.empty()) return 0;
        int maxSum = INT_MIN, minSum = 0;  //minSum的初始值为0，这样确保了在元素都为正数时，sum - minSum = sum。
        int sum = 0;    //sum就是prefix sum，它的初始值是0，就是前缀和数组的第一个元素是0。
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];  //sum即每个点的前缀和
            maxSum = max(maxSum, sum - minSum);  //用当前点的前缀和 减去 之前最小的前缀和，再和全局的maxSum作比较。
            minSum = min(minSum, sum);
        }
        return maxSum;
    }
};

```

---

2. [Leetcode Link：Best time to buy and sell stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/)     

  + **Description**
    Say you have an array for which the ith element is the price of a given stock on day i.      
    If you were only permitted to complete at most one transaction(ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.             

  + **Example**
    Input: `[7, 1, 5, 3, 6, 4]`         
    Output: 5      
    max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)     

    Input: `[7, 6, 4, 3, 1]`       
    Output: 0    
    In this case, no transaction is done, i.e. max profit = 0.      

  + **Solution**     
    - (和Maximum Subarray 是同一个思路) 求股票的最佳买入卖出时间，for一遍所有可以卖出的时间，   
    - 看一下`i - 1`天里最低点min是什么，用当前时间的price 减去 min，得到的今天最大的收益，      
    - 当天的最大收益，和全局里的max最大收益去比较一下，保留最大值。    

  + **C++** **code**     

```cpp    
class Solution {
public:
    /*
     * @param prices: Given an integer array
     * @return: Maximum profit
     */
    int maxProfit(vector<int> &prices) {
        // write your code here
        if (prices.empty()) return 0;
        int max_profit = INT_MIN, min_price = INT_MAX;
        for (int i = 0; i < prices.size(); i++) {
            min_price = min(min_price, prices[i]); //找到截止到当前的最低的价格点。这样就能保证最初的第一个值就是最初的低点。
            max_profit = max(max_profit, prices[i] - min_price);  //用今天的price减去以前的min_price, 在和全局的max_profit作比较。
        }
        return maxSum;
    }
};

```

---

3. [Lintcode Link：Minimum Subarray](http://www.lintcode.com/en/problem/minimum-subarray/)  

  + **Description**
    Given an array of integers, find the subarray with smallest sum.      
	Return the sum of the subarray.      
 
  + **Example**
    For [1, -1, -2, 1], return -3.

  + **Solution**
	- 同Maximum subarray 思路一样，只是把求max转化为求min。      

  + **C++** **code**

```cpp

class Solution {
public:
    /*
     * @param nums: a list of integers
     * @return: A integer indicate the sum of minimum subarray
     */
    int minSubArray(vector<int> &nums) {
        // write your code here
        if (nums.empty()) return 0;
        int minSum = INT_MAX, maxSum = 0;
        int curSum = 0;
        for (int i = 0; i < nums.size(); i++) {
            curSum += nums[i];
            
            minSum = min(minSum, curSum - maxSum);
            
        }
        return minSum;
    }
};

```

---

4. [Lintcode Link：Maximum subarray ii](http://www.lintcode.com/en/problem/maximum-subarray-ii/)  

  + **Description**     
	Given an array of integers, find two non-overlapping subarrays which have the largest sum.   
	The number in each subarray should be contiguous. The subarray should contain at least one number.      
	Return the largest sum.    

  + **Example**  
    For given `[1, 3, -1, 2, -1, 2]`, the two subarrays are `[1, 3]` and `[2, -1, 2]` or `[1, 3, -1, 2]` and `[2]`, they both have the largest sum `7`.

  + **Solution**
    - 因为两个subarray一定不重叠，所以必定存在一条分割线，分开这两个subarrays，我们可以分别求出left 和 right的maxSum，然后再加起来。
    - 具体来说就是，先做两个for循环，一个从左->右 求maxSum；一个从右->左 求maxSum。然后将两个maxSum加起来，和一个全局的max作比较找出最大的sum。

  + **C++ code**     

```cpp
class Solution {
public:
    /*
     * @param nums: A list of integers
     * @return: An integer denotes the sum of max two non-overlapping subarrays
     */
    int maxTwoSubArrays(vector<int> &nums) {
        // write your code here
        if (nums.empty()) return 0;
        int maxSum = INT_MIN, minSum = 0, curSum = 0;
        vector<int> left(nums.size(), INT_MIN);    //注意vector一定要初始化
        vector<int> right(nums.size(), INT_MIN);
        for (int i = 0; i < nums.size(); i++) {    //从左->右 遍历，将每一个maxSum放到left数组中
            curSum += nums[i];
            maxSum = max(maxSum, curSum - minSum);
            minSum = min(minSum, curSum);
            left[i] = maxSum;
        }
        maxSum = INT_MIN;
        minSum = 0;
        curSum = 0;
        for (int i = nums.size() - 1; i >= 0; i--) {      //从右->左 遍历，将每一个maxSum放到left数组中
            curSum += nums[i];
            maxSum = max(maxSum, curSum - minSum);
            minSum = min(minSum, curSum);
            right[i] = maxSum;
        }
        maxSum = INT_MIN;
        for (int i = 0; i < nums.size() - 1; i++) {      //遍历所有的分界线，分界线有nums.size() - 1 个，将每个分界线的left和right的maxSum加起来。
            int cur = left[i] + right[i + 1];            //这里left[i] 和 right[i + 1] 对应，组成了原始的完整数组。
            maxSum = max(maxSum, cur);
        }
        return maxSum;
    }
};

``` 

---







<!-- TOC -->

## 总结：   


---

`2017.09.14`       
